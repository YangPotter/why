<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>Design Pattern-Facade</title>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css" />
		<link rel="stylesheet" type="text/css" href="css/bootstrap-theme.css" />
		<link rel="stylesheet" type="text/css" href="css/docs.min.css" />
		<link rel="stylesheet" type="text/css" href="css/Index.css"/>

		<script type="text/javascript" src="js/jquery.min.js"></script>
		<script type="text/javascript" src="js/bootstrap.js"></script>
	</head>

	<body data-target="#sideNav" data-spy="scroll">
		<div class="jumbotron" style="background-color: #624887;color: white;">
			<div class="container">
				<h1>设计模式&nbsp;<small style="color: white;">Design Pattern</small></h1>
				<br />
				<h2>Hello, DesignPattern!</h2>
				<br />
			  	<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
			  		设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
			  		这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
			 	</p>
			</div>
		</div>
		<div class="container main">
			<div class="row">
				<div class="col-md-2 ">
					<nav id="sideNav" class="bs-docs-sidebar hidden-print hidden-md" data-spy="affix" data-offset-top="400">
						<ul class="nav nav-stacked" >
							<li class="">
								<a href="SimpleFactoryPattern.html">简单工厂模式</a>
							</li>
							<li class="">
								<a href="StrategyPattern.html">策略模式</a>
							</li>
							<li class="">
								<a href="Principle.html">设计模式原则</a>
							</li>
							<li class="">
								<a href="DecorationPattern.html">装饰模式</a>
							</li>
							<li class="">
								<a href="ProxyPattern.html">代理模式</a>
							</li>
							<li class="">
								<a href="Prototype.html">原型模式</a>
							</li>
							<li class="">
								<a href="TemplateMethod.html">模版方法模式</a>
							</li>
							<li class="">
								<a href="#facade">外观模式</a>
								<ul class="nav">
									<li>
										<a href="#StateDemo">模版</a>
									</li>
									<li>
										<a href="#StateUML">类图</a>
									</li>
									<li>
										<a href="#Condition">应用场景</a>
									</li>
									<li>
										<a href="#About">相关模式</a>
									</li>
									<li>
										<a href="#AandD">优点与缺点</a>
									</li>
									<li>
										<a href="#Nature">本质</a>
									</li>
								</ul>
							</li>
							<li class="">
								<a href="BuilderPattern.html">建造者模式</a>
							</li>
							<li class="">
								<a href="ObserverPattern.html">观察者模式</a>
							</li>
							<li class="">
								<a href="AbstractFactory.html">抽象工厂模式</a>
							</li>
							
						</ul>
					</nav>
				</div>
				<div class="col-md-8 ">

					<div class="bs-docs-section">
						<h1 id="facade" class="page-header">外观模式</h1>
						<div class="bs-callout bs-callout-info">
							<p class="lead">
								外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层的接口，这个接口使得这一子系统更加容易使用。
							</p>
						</div><br />
						<p><span class="text-primary">外观(Facade)角色：</span>客户端可以调用这个角色的方法。此角色知晓相关的(一个或者多个)子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。</p>
						<p><span class="text-primary">子系统(subsystem)角色：</span>可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。每一个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 </p>
						<div id="StateDemo" class="bs-callout bs-callout-danger">
							<h2 >模版</h2>
						</div>
						
						<figure class="highlight">
							<pre>
								<code>

//外观模式
package FacadePattern;

//客户端
//可以不知三个子系统类的存在
public class FacadePatternDemo {

	public static void main(String[] args) {
		Facade facade = new Facade();
		
		facade.MethodA();
		facade.MethodB();
	}

}

//外观类，他需要了解所有的子系统的方法或属性，进行组合，以备外界使用。
class Facade {
	SubSystemOne one;
	SubSystemTwo two;
	SubSystemThree three;
	SubSystemFour four;
	
	public Facade() {
		one = new SubSystemOne();
		two = new SubSystemTwo();
		three = new SubSystemThree();
		four = new SubSystemFour();
	}
	
	public void MethodA() {
		one.MethodOne();
		two.MethodTwo();
		four.MethodFour();
	}
	
	public void MethodB() {
		three.MethodThree();
		four.MethodFour();
	}
}

//子系统类
class SubSystemOne {
	public void MethodOne() {
		System.out.println("子系统方法一");
	}
}
class SubSystemTwo {
	public void MethodTwo() {
		System.out.println("子系统方法二");
	}
}
class SubSystemThree {
	public void MethodThree() {
		System.out.println("子系统方法三");
	}
}
class SubSystemFour {
	public void MethodFour() {
		System.out.println("子系统方法四");
	}
}


								</code>
							</pre>
						</figure>

						<div id="StateUML" class="bs-callout bs-callout-danger">
							<h2 >UML类图</h2>
						</div>
						<img src="img/FacadePattern/FacadePattern.cld.jpg" alt="状态模式UML类图" /><br />
						
						<div id="Condition" class="bs-callout bs-callout-danger">
							<h2>应用场景</h2>
						</div>
						<p class="lead">
							建议在如下情况中，选用外观模式：
						</p>
						<ul>
							<li class="text-primary">如果你希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式，使用外观对象来实现大部分客户需要的功能，从而简化客户的使用</li><br />
							<li class="text-primary">如果想要让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将这个子系统与它的客户分离开来，从而提高子系统的独立性和可移植性</li>
							<li class="text-primary">如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系</li>
						</ul>
						<br />
						
						<div id="About" class="bs-callout bs-callout-danger">
						<h2>相关模式</h2>
						</div><br />
						<h3>外观模式和中介者模式</h3><br />
						<p>这两个模式非常类似，但是有本质的区别。
						    中介者模式主要用来封装多个对象之间相互的交互，多用在系统内部的多个模块之间；而外观模式封装的是单向的交互，是从客户端访问系统的调用，没有从系统中来访问客户端的调用。
						    在中介者模式的实现里面，是需要实现具体的交互功能的；而外观模式的实现里面，一般是组合调用或是转调内部实现的功能，通常外观模式本身并不实现这些功能。
						    中介者模式的目的主要是松散多个模块之间的耦合，把这些耦合关系全部放到中介者中去实现；而外观模式的目的是简化客户端的调用，这点和中介者模式也不同。
						</p>
						<h3>外观模式和单例模式</h3><br />
						<p> 通常一个子系统只需要一个外观实例，所以外观模式可以和单例模式组合使用，把Facade类实现成为单例。当然，也可以跟前面示例的那样，把外观类的构造方法私有化，然后把提供给客户端的方法实现成为静态的。</p>
						<br />
						
						
						<div id="AandD" class="bs-callout bs-callout-danger">
							<h2 >优点与缺点</h2>
						</div>
						<div id="AandD" class="bs-callout bs-callout-warning">
							<h4>优点：</h4>
						</div>
							<ul class="list">
								<li class="lead">松散耦合</li>
								<p> 外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</p>
								<li class="lead">简单易用</li>
								<p> 外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，相当于外观类为外部客户端使用子系统提供了一站式服务。</p>
								<li class="lead">更好的划分访问层次</li>
								<p> 通过合理使用Facade，可以帮助我们更好的划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好的隐藏了内部的细节。</p>
							</ul>
						<div id="AandD" class="bs-callout bs-callout-warning">
							<h4>缺点：</h4>
						</div>
							<ul class="list">
								<p>过多的或者是不太合理的Facade也容易让人迷惑，到底是调用Facade好呢，还是直接调用模块好。</p>
							</ul>
						<div id="Nature" class="bs-callout bs-callout-danger">
							<h2 >本质</h2>
						</div>
						<p class="lead">封装交互，简化调用。</p>
					</div>
				</div>
				<div class="col-md-2 ">
					<nav id="sideNav" class="bs-docs-sidebar hidden-print hidden-md affix"data-spy="affix" data-offset-top="460" >
						<ul class="nav bs-docs-sidenav">
							<li class="">
								<a href="StatePattern.html">状态模式</a>
							</li>
							<li class="">
								<a href="AdapterPattern.html">适配器模式</a>
							</li>
							<li class="">
								<a href="MementoPattern.html">备忘录模式</a>
							</li>
							<li class="">
								<a href="Composite.html">组合模式</a>
							</li>
							<li class="">
								<a href="Singleton.html">单例模式</a>
							</li>
							<li class="">
								<a href="BridgePattern.html">桥接模式</a>
							</li>
							<li class="">
								<a href="CommandPattern.html">命令模式</a>
							</li>
							<li class="">
								<a href="ChainOfResponsibility.html">职责链模式</a>
							</li>
							<li class="">
								<a href="Mediator.html">中介者模式</a>
							</li>
							<li class="">
								<a href="FlyweightPattern.html">享元模式</a>
							</li>
							<li class="">
								<a href="VisitorPattern.html">访问者模式</a>
							</li>				
							<li class="">
								<a href="#top" class="back-to-top">返回顶部</a>
							</li>
						</ul>
					</nav>

				</div>
			</div>
		</div>
		
		<footer class="bs-docs-footer">
			<div class="container">
				<h4 align="center"><a href="#top" class="back-to-top">返回顶部</a></h4>
				<h4 align="center">&copy;Made by W.H.Y</h4>
			</div>
		</footer>
	</body>

</html>