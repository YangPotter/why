<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>Design Pattern</title>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css" />
		<link rel="stylesheet" type="text/css" href="css/bootstrap-theme.css" />
		<link rel="stylesheet" type="text/css" href="css/docs.min.css" />
		<link rel="stylesheet" type="text/css" href="css/Index.css"/>

		<script type="text/javascript" src="js/jquery.min.js"></script>
		<script type="text/javascript" src="js/bootstrap.js"></script>
		<style type="text/css">
			.a {
				background: lightgray;
				border: 1px solid black;
			}
		</style>
	</head>

	<body data-target="#sideNav" data-spy="scroll">
		<div class="jumbotron" style="background-color: #624887;color: white;">
			<div class="container">
				<h1>设计模式&nbsp;<small style="color: white;">Design Pattern</small></h1>
				<br />
				<h2>Hello, DesignPattern!</h2>
				<br />
			  	<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
			  		设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
			  		这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
			 	</p>
			</div>
		</div>
		<div class="container main">
			<div class="row">
				<div class="col-md-2 ">
					<nav id="sideNav" class="bs-docs-sidebar hidden-print hidden-md" data-spy="affix" data-offset-top="440">
						<ul class="nav nav-stacked" >
							<li class="">
								<a href="#simpleFactory">简单工厂模式</a>
								<ul class="nav">
									<li>
										<a href="#">实例</a>
									</li>
									<li>
										<a href="#">类图</a>
									</li>
									<li>
										<a href="#">优点与缺点</a>
									</li>
									<li>
										<a href="#">本质</a>
									</li>
								</ul>
							</li>
							<li class="">
								<a href="#stratagePattern">策略模式</a>
							</li>
							<li class="">
								<a href="#principle">设计模式原则</a>
								<ul class="nav">
									<li>
										<a href="#SRP ">单一职责原则</a>
									</li>
									<li>
										<a href="#OCP">开放-封闭原则</a>
									</li>
									<li>
										<a href="#DIP">依赖倒转原则</a>
									</li>
									<li>
										<a href="#LSP">里氏代换原则</a>
									</li>
									<li>
										<a href="#LOD">迪米特法则</a>
									</li>
								</ul>
							</li>
							<li class="">
								<a href="#decorator">装饰模式</a>
							</li>
							<li class="">
								<a href="#proxy">代理模式</a>
							</li>
							<li class="">
								<a href="#factoryMethod">工厂方法模式</a>
							</li>
							<li class="">
								<a href="#prototype">原型模式</a>
							</li>
							<li class="">
								<a href="#template">模版方法模式</a>
							</li>
							<li class="">
								<a href="#facade">外观模式</a>
							</li>
							<li class="">
								<a href="#builder">建造者模式</a>
							</li>
							<li class="">
								<a href="#observer">观察者模式</a>
							</li>
							<li class="">
								<a href="#abstractFactory">抽象工厂模式</a>
							</li>
							
						</ul>
					</nav>
				</div>
				<div class="col-md-8 ">
					<div class="bs-docs-section">
						<h1 id="simpleFactory" class="page-header">
							简单工厂模式
						</h1> 
						<div class="bs-callout bs-callout-info">
							<p class="lead">
								工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
							</p>
						</div>
						
					</div>
					<div class="bs-docs-section">
						<h1 id="stratagePattern" class="page-header">策略模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="principle" class="page-header">设计模式原则</h1>
						<h2 id="SRP" class="page-header">单一职责原则</h2>
						<h2 id="OCP" class="page-header">开放-封闭原则</h2>
						<h2 id="DIP" class="page-header">依赖倒转原则</h2>
						<h2 id="LSP" class="page-header">里氏代换原则</h2>
						<h2 id="LOD" class="page-header">迪米特法则</h2>
					</div>
					<div class="bs-docs-section">
						<h1 id="decorator" class="page-header">装饰模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="proxy" class="page-header">代理模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="factoryMethod" class="page-header">工厂方法模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="prototype" class="page-header">原型模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="template" class="page-header">模版方法模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="facade" class="page-header">外观模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="builder" class="page-header">建造者模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="observer" class="page-header">观察者模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="abstractFactory" class="page-header">抽象工厂模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="state" class="page-header">状态模式</h1>
						<div class="bs-callout bs-callout-info">
							<p class="lead">
								在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。
								在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
							</p>
						</div>
						<br />
						<h2 id="StateUML">UML类图</h2>
						<img src="img/StatePattern/StateDemo.cld.jpg" alt="状态模式UML类图" />
						<h2 id="StateExample">
							<figure class="highlight">
								<pre>
									<code class="language-java" data-lang="java">
public class StatePatternExample {
	public static void main(String args[]) {        //客户端界面
		Work Projects = new Work();
		Projects.setHour(9);
		Projects.WriteProgram();
		Projects.setHour(10);
		Projects.WriteProgram();
		Projects.setHour(12);
		Projects.WriteProgram();
		Projects.setHour(13);
		Projects.WriteProgram();
		Projects.setHour(14);
		Projects.WriteProgram();
		Projects.setHour(17);
		
		//Projects.setFinish(true);
		Projects.setFinish(false);
		
		Projects.WriteProgram();
		Projects.setHour(19);
		Projects.WriteProgram();
		Projects.setHour(22);
		Projects.WriteProgram();
	}

}

class Work {      //工作类
	private WorkState current;
	private double hour;
	private boolean finish = false;
	
	public Work() {
		current = new ForenoonWorkState();
	}
	
	public void SetWorkState(WorkState s) {
		current = s;
	}
	
	public void WriteProgram() {
		current.WriteProgram(this);
	}

	public double getHour() {
		return hour;
	}

	public void setHour(double hour) {
		this.hour = hour;
	}

	public boolean getFinish() {
		return finish;
	}

	public void setFinish(boolean finish) {
		this.finish = finish;
	}
}

abstract class WorkState {      //抽象状态
	public abstract void WriteProgram(Work w);
}

class ForenoonWorkState extends WorkState {     //上午工作状态
	public void WriteProgram(Work w) {
		if(w.getHour() < 12) {
			System.out.println("当前时间：" + w.getHour() + "点 上午工作，精神百倍!");
		}else {
			w.SetWorkState(new NoonWorkState());
			w.WriteProgram();
		}
	}
}

class NoonWorkState extends WorkState {     //中午工作状态
	public void WriteProgram(Work w) {
		if(w.getHour() < 13) {
			System.out.println("当前时间：" + w.getHour() + "点 饿了，午饭；犯困，午休。");
		}else {
			w.SetWorkState(new AfternoonWorkState());
			w.WriteProgram();
		}
	}
}

class AfternoonWorkState extends WorkState {     //下午工作状态
	public void WriteProgram(Work w) {
		if(w.getHour() < 17) {
			System.out.println("当前时间：" + w.getHour() + "点 下午状态还不错，继续努力！");
		}else {
			w.SetWorkState(new EveningWorkState());
			w.WriteProgram();
		}
	}
}

class EveningWorkState extends WorkState {     //晚间工作状态
	public void WriteProgram(Work w) {
		if(w.getFinish()) {
			w.SetWorkState(new RestWorkState());
			w.WriteProgram();
		}else {
			if(w.getHour() < 21) {
				System.out.println("当前时间：" + w.getHour() + "点 加班，疲累之极！");
			}else {
				w.SetWorkState(new SleepingWorkState());
				w.WriteProgram();
			}
		}
		
	}
}

class SleepingWorkState extends WorkState {     //睡眠状态
	public void WriteProgram(Work w) {
		System.out.println("当前时间：" + w.getHour() + "点 不行了，睡着了......");
	}
}

class RestWorkState extends WorkState {     //下班休息状态
	public void WriteProgram(Work w) {
		System.out.println("当前时间：" + w.getHour() + "点 下班回家啦！");
	}
}
									</code>
								</pre>
							</figure>
						</h2>
					</div>
					<div class="bs-docs-section">
						<h1 id="adapter" class="page-header">适配器模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="memento" class="page-header">备忘录模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="composite" class="page-header">组合模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="iterator" class="page-header">迭代器模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="singleton" class="page-header">单例模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="bridge" class="page-header">桥接模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="command" class="page-header">命令模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="responsibility" class="page-header">职责链模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="mediator" class="page-header">中介者模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="flyweight " class="page-header">享元模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="interpreter" class="page-header">解释器模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="visitor" class="page-header">访问者模式</h1>
					</div>
					<div class="bs-docs-section">
						<h1 id="summary" class="page-header">模式总结</h1>
					</div>

				</div>
				<div class="col-md-2 ">
					<nav id="sideNav" class="bs-docs-sidebar hidden-print hidden-md affix"data-spy="affix" data-offset-top="460" >
						<ul class="nav bs-docs-sidenav">
							<li class="">
								<a href="#state">状态模式</a>
								<ul class="nav">
									<li>
										<a href="#">实例</a>
									</li>
									<li>
										<a href="#StateUML">类图</a>
									</li>
									<li>
										<a href="#">优点与缺点</a>
									</li>
									<li>
										<a href="#">本质</a>
									</li>
								</ul>
							</li>
							<li class="">
								<a href="#adapter">适配器模式</a>
							</li>
							<li class="">
								<a href="#memento">备忘录模式</a>
							</li>
							<li class="">
								<a href="#composite">组合模式</a>
							</li>
							<li class="">
								<a href="#iterator">迭代器模式</a>
							</li>
							<li class="">
								<a href="#singleton">单例模式</a>
							</li>
							<li class="">
								<a href="#bridge">桥接模式</a>
							</li>
							<li class="">
								<a href="#command">命令模式</a>
							</li>
							<li class="">
								<a href="#responsibility">职责链模式</a>
							</li>
							<li class="">
								<a href="#mediator">中介者模式</a>
							</li>
							<li class="">
								<a href="#flyweight">享元模式</a>
							</li>
							<li class="">
								<a href="#interpreter">解释器模式</a>
							</li>
							<li class="">
								<a href="#visitor">访问者模式</a>
							</li>
							<li class="">
								<a href="#summary">模式总结</a>
							</li>							
							<li class="">
								<a href="#top" class="back-to-top">返回顶部</a>
							</li>
						</ul>
					</nav>

				</div>
			</div>
		</div>
		<div class="container footer">
			<div class="row">

			</div>
			<div class="row">

			</div>
		</div>
	</body>

</html>